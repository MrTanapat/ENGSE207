#### คำถาม 1: การเปรียบเทียบโครงสร้าง (5 คะแนน)

**ก. จำนวนบรรทัดโค้ดและไฟล์**

สร้างตารางเปรียบเทียบ:

| ข้อมูล | Monolithic (Week 3) | Layered (Week 4) |
|--------|---------------------|------------------|
| จำนวนไฟล์ JS หลัก | 2 | 10 |
| จำนวนบรรทัดทั้งหมด | 644 | 1107 |
| จำนวน layers | 1 | 3 |
| ความซับซ้อนโดยรวม | 1 | 3|

**คำถาม:**
1. Layered มีจำนวนไฟล์และบรรทัดโค้ดมากกว่าหรือน้อยกว่า Monolithic? เพราะอะไร?
```
เพราะ Layered แยกการทำงานออกเป็นหลายๆไฟล์เพื่อทำน้าที่เฉพาะรวมถึงเชื่อระหว่าง layeres
แต่ Monolithic รวมทุกหน้าที่ไว้ในไฟล์เดียวทำให้มีโค๊ดและไฟล์น้อยกว่า
```
3. ความซับซ้อนที่เพิ่มขึ้นคุ้มค่าหรือไม่? อธิบาย
```
คุ้มค่าในงานขนาดกลาง-ใหญ่ หรือทำงานเป็นทีม เพราะง่ายต่อการดูแล รักษา ขยาย
```

#### คำถาม 2: จุดแข็ง-จุดอ่อน (10 คะแนน)

**วิเคราะห์จุดแข็งของ Layered Architecture:**

สร้างตารางวิเคราะห์:

| Quality Attribute | Monolithic | Layered | คะแนน<br>(1-5) | อธิบายเหตุผล |
|-------------------|------------|---------|--------|-------------|
| **Maintainability**<br>(ความง่ายในการดูแล) | 1 | 5 | 5 | Monolithic รวมทุกอย่างไว้ในไฟล์เดียว ทำให้เมื่อโค้ดใหญ่ขึ้นแก้ไขยาก ในขณะที่ Layered แยกหน้าที่ชัดเจน |
| **Testability**<br>(ความง่ายในการทดสอบ) | 1 | 5 | 4 | Monolithic ต้องรันทั้งแอปเพื่อทดสอบบางส่วน Layered สามารถทดสอบ service แยกจาก server ได้ |
| **Modifiability**<br>(ความง่ายในการแก้ไข) | 1 | 5 | 5 | Monolithic การแก้ logic หนึ่งอาจกระทบหลายส่วน Layered การแก้ไขใน service แยกได้ |
| **Reusability**<br>(การนำกลับมาใช้ใหม่) | 1 | 5 | 5 | Monolithic มักผูกกับ route โดยตรง นำไปใช้ซ้ำยาก Layered สามารถนำ service เดิมไปใช้กับหลาย route หรือ API  |
| **Team Collaboration**<br>(การทำงานเป็นทีม) | | | | Monolithic มีโอกาส merge conflict สูงเพราะแก้ไฟล์เดียวกันหลายคน Layered แยกไฟล์ตามหน้าที่ ทำให้ทีมสามารถทำงานร่วมกันได้ง่าย |
| **Performance**<br>(ประสิทธิภาพ) | | | | |
| **Simplicity**<br>(ความเรียบง่าย) | | | | |

**คำแนะนำ:**
- ให้คะแนน 1-5 (1 = แย่ที่สุด, 5 = ดีที่สุด)
- อธิบายเหตุผลอย่างละเอียด โดยยกตัวอย่างจากโค้ดจริง
- เปรียบเทียบว่าส่วนไหนของโค้ดทำให้ดีขึ้นหรือแย่ลง

#### คำถาม 3: สถานการณ์จริง (5 คะแนน)

**วิเคราะห์สถานการณ์ต่อไปนี้:**

**สถานการณ์ที่ 1:** ต้องการเพิ่มฟีเจอร์ "assign task to user"
- ใน Monolithic จะต้องแก้ไขอย่างไร?
- ใน Layered จะต้องแก้ไขอย่างไร?
- แบบไหนง่ายกว่า? เพราะอะไร?

**คำตอบของคุณ:**
```
Monolithic:




Layered:




สรุป:


```

**สถานการณ์ที่ 2:** มีบั๊กที่ validation logic (ตรวจสอบ title)
- ใน Monolithic จะต้องหาบั๊กและแก้ไขที่ไหน?
- ใน Layered จะต้องหาบั๊กและแก้ไขที่ไหน?
- แบบไหนง่ายกว่า? เพราะอะไร?

**คำตอบของคุณ:**
```
Monolithic:




Layered:




สรุป:


```

**สถานการณ์ที่ 3:** ต้องการเปลี่ยนจาก SQLite เป็น PostgreSQL
- ใน Monolithic จะต้องแก้ไขกี่ที่?
- ใน Layered จะต้องแก้ไขกี่ที่?
- แบบไหนง่ายกว่า? เพราะอะไร?

**คำตอบของคุณ:**
```
Monolithic:




Layered:




สรุป:


```

#### คำถาม 4: Trade-offs (5 คะแนน)

**วิเคราะห์ Trade-offs:**

1. **Complexity vs Maintainability**
   - Layered มีความซับซ้อนมากขึ้น แต่ดูแลง่ายขึ้น
   - คุณคิดว่า trade-off นี้คุ้มค่าหรือไม่? เพราะอะไร?
   - ในกรณีไหนที่คุ้มค่า? ในกรณีไหนที่ไม่คุ้มค่า?

**คำตอบของคุณ:**
```







```

2. **Performance Overhead**
   - Layered มี overhead จากการเรียกผ่าน layers
   - คุณคิดว่ามีผลกระทบมากแค่ไหน?
   - ในแอปพลิเคชันประเภทใดที่ performance overhead นี้สำคัญ?

**คำตอบของคุณ:**
```







```

#### คำถาม 5: การตัดสินใจเลือกใช้ (5 คะแนน)

**ออกแบบกฎการตัดสินใจ:**

สร้าง Decision Tree สำหรับตัดสินใจว่าจะใช้ Monolithic หรือ Layered:

```
เริ่มต้นโปรเจกต์
│
├─ ขนาดทีม?
│  ├─ 1-2 คน → [คำตอบของคุณ]
│  └─ 3+ คน → [คำตอบของคุณ]
│
├─ ขนาดโปรเจกต์?
│  ├─ เล็ก (< 1000 บรรทัด) → [คำตอบของคุณ]
│  ├─ กลาง (1000-10000 บรรทัด) → [คำตอบของคุณ]
│  └─ ใหญ่ (> 10000 บรรทัด) → [คำตอบของคุณ]
│
├─ ระยะเวลาพัฒนา?
│  ├─ ต้องการเร็ว (< 1 เดือน) → [คำตอบของคุณ]
│  └─ มีเวลา (> 1 เดือน) → [คำตอบของคุณ]
│
└─ ต้องการ maintainability สูง?
   ├─ ใช่ → [คำตอบของคุณ]
   └─ ไม่ → [คำตอบของคุณ]
```

**อธิบายเหตุผลของการตัดสินใจแต่ละข้อ:**
```








```

---
